# Migrating to the Concurrent Solver

In this how-to guide, we explain what changes should be made to enable the
concurrent solver for a Statix project.


## Enabling the Concurrent solver for a Language

To enable the concurrent solver for a language, set the `language.statix.concurrent`
property in the `metaborg.yaml` file to `true`. This ensures that the
concurrent solver is used for all sources in the language.

```yaml
id: org.example:mylang:0.1.0-SNAPSHOT
name: mylang
language:
  statix:
    mode: concurrent
```


## Enabling the Concurrent solver for an Example Project only

To enable the concurrent solver for a particular project only, set the
`runtime.statix.modes` property in the `metaborg.yaml` file to a map
that contains all names of the languages for which you want to use the
concurrent solver, and their corresponding modes. The name of the language
should correspond to the `name` property in the `metaborg.yaml` of the
language definition project.


```yaml
id: org.example:mylang.example:0.1.0-SNAPSHOT
runtime:
  statix:
    modes:
    - mylang: concurrent
```

## Indirect Type Declaration

Type checking with the concurrent solver might result in
deadlock when type-checkers have mutual dependencies on their declarations.
This problem can be solved by adding an intermediate declaration that splits
the part of the declaration data that is filtered on (usually the declaration
*name*), and the part that is processed further by the querying unit (usually
the *type*). This pattern is best explained with an example:

```statix
signature
  relations
    type : ID -> TYPE

rules
  declareType : scope * ID * TYPE
  resolveType : scope * ID -> TYPE

  declareType(s, x, T) :-
    !type[x, T] in s.

  resolveType(s, x) = T :-
    query type
      filter P* I* and { x' :- x' == x }
          in s |-> [(_, (_, T))].
```

This specification needs to be changed in the following:

```statix
signature
  relations
    type   : ID -> scope
    typeOf : TYPE

rules
  declareType : scope * ID * TYPE
  resolveType : scope * ID -> TYPE

  declareType(s, x, T) :-
    !type[x, withType(T)] in s.

  resolveType(s, x) = typeOf(T) :-
    query type
      filter P* I* and { x' :- x' == x }
          in s |-> [(_, (_, T))].
```

We now discuss the changes one-by-one. First, the signature of relation `type`
is be changed to `ID -> scope`. In this scope, we store the type using the
newly introduced `typeOf` relation. This relation only carries a single `TYPE`
term. In this way, the original term is still indirectly present in the outer
declaration.

The `withType` and `typeOf` rules allow to convert between these representations.
The `withType` rule creates a scope with a `typeOf` declaration that contains
the type.  In the adapted `declareType` rule, this constraint is used to
convert the `T` argument to the representation that the `type` relation accepts.
Likewise, the `typeOf` rule queries the `typeOf` declaration to extract the
type from a scope. This rule is used in the `resolveType` rule to convert
back to the term representation of a type.

Performing this change should resolve potential deadlocks when executing your
specifications. Because the signatures of the rules in the original specification
did not change, and the new specification should have identical semantics,
the remainder of the specification should not be affected.

## Using Grouping

!!! todo
    Explain grouping

## Using Libraries

Secondly, the concurrent solver allows to export the scope graph of a project in
a library. These libraries can be linked with other projects, potentially
decreasing analysis times significantly. Statix libraries can be generated and
linked by following three steps.

As a first step, use the `#gui Spoofax ‣ Statix ‣ Make project library` menu on 
a file in your library project to export its scope graph. A `project.stxlib`
file will now appear in the root directory of that project.

!!! warning "Project Scope Configuration"
    Currently, the project scope in the `project.stxlib` file must still be configured
    manually. Some understanding of the Statix library format is helpful for that.
    The signature for Statix libraries looks roughly as follows:

    ```statix
    sorts Library constructors
      Library : list(Scope) * list(Scope) * ScopeGraph -> Library

    sorts ScopeGraph constructors
      ScopeGraph: list((Scope * Datum? * list(Edge))) -> ScopeGraph
    ```

    The top-level `Library` term contains (in this order): the list of shared scopes,
    the list of all scopes of the library, and the actual scope graph.
    A scope graph consists of scope entries, which are defined as three-tuples of:
    scope, datum associated to that scope, and the list of outgoing edges for that scope.

    In order to configure the root scopes correctly, perform the following steps:

    1. Identify the project scope. Names of the project scope are:
       `Scope("/.", "s_prj-0")` for project scopes generated by the concurrent solver,
       and `Scope("", "s_1-1")` for project scopes generated by the traditional solver.
    2. Add the project scope to the list of shared scopes in the exported library.
       Instead of `Library([], ...)`, this term should now look like `Library([Scope("/.", "s_prj-0")], ...)`.
    3. Remove the datum on the project scope. To do this, find the project scope
       entry in the scope graph, and change its second argument from `Some(...)`
       to `None()`. The entry should now roughly look like `(Scope("/.", "s_prj-0"), None(), [...])`.

The second step is to copy this file in the `lib/` directory of the project
that will use the library. Additionally, you might rename the file to something
more descriptive (e.g. `stdlib`), but ensure that the `.stxlib` extension is preserved.

Thirdly, the library must be enabled. To enable the library, create a `lib/stxlibs`
file (no extension) that contains a list of enabled library names. Continuing our
previous example, the content of that file would be `["stdlib"]`.

??? note "Multiple Libraries"
    Using multiple libraries is supported by adding multple `*.stxlib` files in
    the `lib/` directory, and having multiple entries in the `stxlibs` file. An
    example of such a file could look like `["lib1", "lib2"]`. Note however that
    libraries will not link properly when different exports are used, due to the
    fact that scope identities are not deterministic.

## Incremental Solver

Thirdly, there is experimental support for incremental analysis. To enable this,
the following options for the `mode`/`modes` settings are available:

- In language projects: `incremental-scope-graph-diff`.
- In example projects: `incremental-deadlock` or `incremental-scope-graph-diff`.
